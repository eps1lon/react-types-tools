--- types/react//jsx-dev-runtime.d.ts	2024-03-26 16:07:49
+++ types/react//ts5.0//jsx-dev-runtime.d.ts	2024-03-26 16:07:49
@@ -2,7 +2,6 @@
 export { Fragment } from "./";
 
 export namespace JSX {
-    type ElementType = React.JSX.ElementType;
     interface Element extends React.JSX.Element {}
     interface ElementClass extends React.JSX.ElementClass {}
     interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
--- types/react//jsx-runtime.d.ts	2024-03-26 16:07:49
+++ types/react//ts5.0//jsx-runtime.d.ts	2024-03-26 16:07:49
@@ -2,7 +2,6 @@
 export { Fragment } from "./";
 
 export namespace JSX {
-    type ElementType = React.JSX.ElementType;
     interface Element extends React.JSX.Element {}
     interface ElementClass extends React.JSX.ElementClass {}
     interface ElementAttributesProperty extends React.JSX.ElementAttributesProperty {}
--- types/react//test/experimental.tsx	2024-06-11 17:42:37
+++ types/react//ts5.0//test/experimental.tsx	2024-06-11 17:42:37
@@ -74,6 +74,7 @@
 
 function elementTypeTests() {
     const ReturnPromise = () => Promise.resolve("React");
+    // @ts-expect-error Needs https://github.com/DefinitelyTyped/DefinitelyTyped/pull/65135
     const FCPromise: React.FC = ReturnPromise;
     class RenderPromise extends React.Component {
         render() {
@@ -81,7 +82,9 @@
         }
     }
 
+    // @ts-expect-error Needs https://github.com/DefinitelyTyped/DefinitelyTyped/pull/65135
     <ReturnPromise />;
+    // @ts-expect-error Needs https://github.com/DefinitelyTyped/DefinitelyTyped/pull/65135
     React.createElement(ReturnPromise);
     <RenderPromise />;
     React.createElement(RenderPromise);
--- types/react//test/index.ts	2024-06-11 17:42:37
+++ types/react//ts5.0//test/index.ts	2024-06-11 17:42:37
@@ -235,6 +235,9 @@
 // allows null as props
 const FunctionComponent4: React.FunctionComponent = props => null;
 
+// undesired: Rejects `false` because of https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051
+// leaving here to document limitation and inspect error message
+// @ts-expect-error
 const FunctionComponent5: React.FunctionComponent = () => false;
 
 // React.createFactory
@@ -487,7 +490,7 @@
 // Attributes
 // --------------------------------------------------------------------------
 
-const children: any[] = ["Hello world", [null], React.createElement("span")];
+const children: any[] = ["Hello world", [null], React.createElement("span", null)];
 const divStyle: React.CSSProperties = { // CSSProperties
     flex: "1 1 main-size",
     backgroundImage: "url('hello.png')",
--- types/react//test/tsx.tsx	2024-07-08 13:05:09
+++ types/react//ts5.0//test/tsx.tsx	2024-07-08 13:05:09
@@ -689,15 +689,12 @@
 
 function elementTypeTests() {
     const ReturnVoid = () => {};
-    // @ts-expect-error
-    const FCVoid: React.FC = ReturnVoid;
     class RenderVoid extends React.Component {
         // @ts-expect-error
         render() {}
     }
 
     const ReturnUndefined = () => undefined;
-    const FCUndefined: React.FC = ReturnUndefined;
     class RenderUndefined extends React.Component {
         render() {
             return undefined;
@@ -705,7 +702,6 @@
     }
 
     const ReturnNull = () => null;
-    const FCNull: React.FC = ReturnNull;
     class RenderNull extends React.Component {
         render() {
             return null;
@@ -713,7 +709,6 @@
     }
 
     const ReturnNumber = () => 0xeac1;
-    const FCNumber: React.FC = ReturnNumber;
     class RenderNumber extends React.Component {
         render() {
             return 0xeac1;
@@ -721,7 +716,6 @@
     }
 
     const ReturnString = () => "Hello, Dave!";
-    const FCString: React.FC = ReturnString;
     class RenderString extends React.Component {
         render() {
             return "Hello, Dave!";
@@ -729,8 +723,6 @@
     }
 
     const ReturnSymbol = () => Symbol.for("react");
-    // @ts-expect-error
-    const FCSymbol: React.FC = ReturnSymbol;
     class RenderSymbol extends React.Component {
         // @ts-expect-error
         render() {
@@ -739,7 +731,6 @@
     }
 
     const ReturnArray = () => [<div key="one" />];
-    const FCVArray: React.FC = ReturnArray;
     class RenderArray extends React.Component {
         render() {
             return [<div key="one" />];
@@ -747,7 +738,6 @@
     }
 
     const ReturnElement = () => <div />;
-    const FCElement: React.FC = ReturnElement;
     class RenderElement extends React.Component {
         render() {
             return <div />;
@@ -755,7 +745,6 @@
     }
 
     const ReturnReactNode = ({ children }: { children?: React.ReactNode }) => children;
-    const FCReactNode: React.FC = ReturnReactNode;
     class RenderReactNode extends React.Component<{ children?: React.ReactNode }> {
         render() {
             return this.props.children;
@@ -763,7 +752,7 @@
     }
 
     const ReturnPromise = () => Promise.resolve("React");
-    // Will not type-check in a real project but accepted in DT tests since experimental.d.ts is part of compilation.
+    // @ts-expect-error experimental release channel only
     const FCPromise: React.FC = ReturnPromise;
     class RenderPromise extends React.Component {
         // Will not type-check in a real project but accepted in DT tests since experimental.d.ts is part of compilation.
@@ -773,6 +762,7 @@
     }
 
     const ReturnPromiseReactNode = async ({ children }: { children?: React.ReactNode }) => children;
+    // @ts-expect-error experimental release channel only
     const FCPromiseReactNode: React.FC = ReturnReactNode;
     class RenderPromiseReactNode extends React.Component<{ children?: React.ReactNode }> {
         // @ts-expect-error class components cannot render async
@@ -814,8 +804,10 @@
     // @ts-expect-error
     React.createElement(RenderVoid);
 
-    // Desired behavior.
+    // Undesired behavior. Returning `undefined` should be accepted in all forms.
+    // @ts-expect-error
     <ReturnUndefined />;
+    // @ts-expect-error
     React.createElement(ReturnUndefined);
     <RenderUndefined />;
     React.createElement(RenderUndefined);
@@ -826,14 +818,18 @@
     <RenderNull />;
     React.createElement(RenderNull);
 
-    // Desired behavior.
+    // Undesired behavior. Returning `number` should be accepted in all forms.
+    // @ts-expect-error
     <ReturnNumber />;
+    // @ts-expect-error
     React.createElement(ReturnNumber);
     <RenderNumber />;
     React.createElement(RenderNumber);
 
-    // Desired behavior.
+    // Undesired behavior. Returning `string` should be accepted in all forms.
+    // @ts-expect-error
     <ReturnString />;
+    // @ts-expect-error
     React.createElement(ReturnString);
     <RenderString />;
     React.createElement(RenderString);
@@ -848,7 +844,10 @@
     // @ts-expect-error
     React.createElement(RenderSymbol);
 
+    // Undesired behavior. Returning `Array` should be accepted in all forms.
+    // @ts-expect-error
     <ReturnArray />;
+    // @ts-expect-error
     React.createElement(ReturnArray);
     <RenderArray />;
     React.createElement(RenderArray);
@@ -859,15 +858,17 @@
     <RenderElement />;
     React.createElement(RenderElement);
 
-    // Desired behavior.
+    // Undesired behavior. Returning `ReactNode` should be accepted in all forms.
+    // @ts-expect-error
     <ReturnReactNode />;
+    // @ts-expect-error
     React.createElement(ReturnReactNode);
     <RenderReactNode />;
     React.createElement(RenderReactNode);
 
-    // Will not type-check in a real project but accepted in DT tests since experimental.d.ts is part of compilation.
+    // @ts-expect-error Only available in experimental release channel
     <ReturnPromise />;
-    // Will not type-check in a real project but accepted in DT tests since experimental.d.ts is part of compilation.
+    // @ts-expect-error Only available in experimental release channel
     React.createElement(ReturnPromise);
     // Will not type-check in a real project but accepted in DT tests since experimental.d.ts is part of compilation.
     <RenderPromise />;
--- types/react//index.d.ts	2024-07-02 12:59:18
+++ types/react//ts5.0//index.d.ts	2024-06-11 17:42:37
@@ -121,7 +121,7 @@
              * @see {@link https://legacy.reactjs.org/docs/legacy-context.html#referencing-context-in-stateless-function-components React Docs}
              */
             deprecatedLegacyContext?: any,
-        ) => ReactNode)
+        ) => ReactElement<any, any> | null)
         | (new(
             props: P,
             /**
@@ -222,7 +222,7 @@
         C extends
             | ForwardRefExoticComponent<any>
             | { new(props: any): Component<any> }
-            | ((props: any, deprecatedLegacyContext?: any) => ReactNode)
+            | ((props: any, deprecatedLegacyContext?: any) => ReactElement | null)
             | keyof JSX.IntrinsicElements,
     > =
         // need to check first if `ref` is a valid prop for ts@3.0
@@ -440,6 +440,7 @@
     type ReactFragment = Iterable<ReactNode>;
 
     /**
+     * For internal usage only.
      * Different release channels declare additional types of ReactNode this particular release channel accepts.
      * App or library types should never augment this interface.
      */
@@ -632,7 +633,7 @@
      * @template P The props the component accepts.
      */
     interface ExoticComponent<P = {}> {
-        (props: P): ReactNode;
+        (props: P): ReactElement | null;
         readonly $$typeof: symbol;
     }
 
@@ -1119,7 +1120,7 @@
              * @see {@link https://legacy.reactjs.org/docs/legacy-context.html#referencing-context-in-lifecycle-methods React Docs}
              */
             deprecatedLegacyContext?: any,
-        ): ReactNode;
+        ): ReactElement<any, any> | null;
         /**
          * Used to declare the types of the props accepted by the
          * component. These types will be checked during rendering
@@ -1206,7 +1207,7 @@
              * @see {@link https://legacy.reactjs.org/docs/legacy-context.html#referencing-context-in-lifecycle-methods React Docs}
              */
             deprecatedLegacyContext?: any,
-        ): ReactNode;
+        ): ReactElement<any, any> | null;
         propTypes?: WeakValidationMap<P> | undefined;
         contextTypes?: ValidationMap<any> | undefined;
         /**
@@ -1237,7 +1238,7 @@
      * @see {@link forwardRef}
      */
     interface ForwardRefRenderFunction<T, P = {}> {
-        (props: P, ref: ForwardedRef<T>): ReactNode;
+        (props: P, ref: ForwardedRef<T>): ReactElement | null;
         /**
          * Used in debugging messages. You might want to set it
          * explicitly if you want to display a different name for
@@ -4236,7 +4237,6 @@
 
     // Keep in sync with JSX namespace in ./jsx-runtime.d.ts and ./jsx-dev-runtime.d.ts
     namespace JSX {
-        type ElementType = GlobalJSXElementType;
         interface Element extends GlobalJSXElement {}
         interface ElementClass extends GlobalJSXElementClass {}
         interface ElementAttributesProperty extends GlobalJSXElementAttributesProperty {}
@@ -4298,18 +4298,6 @@
      * @deprecated Use `React.JSX` instead of the global `JSX` namespace.
      */
     namespace JSX {
-        // We don't just alias React.ElementType because React.ElementType
-        // historically does more than we need it to.
-        // E.g. it also contains .propTypes and so TS also verifies the declared
-        // props type does match the declared .propTypes.
-        // But if libraries declared their .propTypes but not props type,
-        // or they mismatch, you won't be able to use the class component
-        // as a JSX.ElementType.
-        // We could fix this everywhere but we're ultimately not interested in
-        // .propTypes assignability so we might as well drop it entirely here to
-        //  reduce the work of the type-checker.
-        // TODO: Check impact of making React.ElementType<P = any> = React.JSXElementConstructor<P>
-        type ElementType = string | React.JSXElementConstructor<any>;
         interface Element extends React.ReactElement<any, any> {}
         interface ElementClass extends React.Component<any> {
             render(): React.ReactNode;
@@ -4523,7 +4511,6 @@
 // React.JSX needs to point to global.JSX to keep global module augmentations intact.
 // But we can't access global.JSX so we need to create these aliases instead.
 // Once the global JSX namespace will be removed we replace React.JSX with the contents of global.JSX
-type GlobalJSXElementType = JSX.ElementType;
 interface GlobalJSXElement extends JSX.Element {}
 interface GlobalJSXElementClass extends JSX.ElementClass {}
 interface GlobalJSXElementAttributesProperty extends JSX.ElementAttributesProperty {}
